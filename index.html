<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Visor de Fractales Optimizado (PC y Móvil)</title>
    <style>
        /* Estilos generales */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #0a0a0a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: white;
            /* Evita el comportamiento táctil por defecto del navegador (scroll, zoom, etc.) */
            touch-action: none; 
        }
        #fractalCanvas {
            display: block;
            cursor: crosshair;
            transition: filter 0.5s ease;
        }
        #fractalCanvas.rendering {
            filter: blur(2px) brightness(0.8);
        }

        /* Contenedor para los controles */
        #controls {
            position: absolute;
            bottom: 15px;
            left: 15px;
        }

        /* Estilos para el texto de ayuda */
        .info-box {
            padding: 12px 15px;
            background-color: rgba(0, 0, 0, 0.75);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none; /* Permite que los toques pasen a través */
        }
        .info-box p { margin: 0 0 5px 0; }
        .info-box p:last-child { margin-bottom: 0; }

        /* Indicador de renderizado en el centro */
        #render-indicator {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 8px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 500;
        }
        #render-indicator.visible { opacity: 1; }
    </style>
</head>
<body>

    <canvas id="fractalCanvas"></canvas>
    <div id="render-indicator">Calculando...</div>
    
    <div id="controls">
        <div class="info-box">
            <p><strong>Explorador de Mandelbrot</strong></p>
            <p><b>PC:</b> Rueda del mouse para zoom.</p>
            <p><b>Móvil:</b> Pellizca para zoom, arrastra para mover.</p>
        </div>
    </div>

    <!-- El código del Web Worker se define aquí para mantenerlo en un solo archivo -->
    <script id="fractal-worker" type="javascript/worker">
        // --- CÓDIGO DEL WEB WORKER ---
        // Este código se ejecuta en un hilo separado.

        function getColor(iteration, max) {
            if (iteration === max) return { r: 0, g: 0, b: 0 };
            const t = iteration / max;
            const r = Math.round(255 * (0.5 * (1 + Math.cos(3.0 + t * 15.0 + 0.2))));
            const g = Math.round(255 * (0.5 * (1 + Math.cos(2.5 + t * 12.0 + 0.5))));
            const b = Math.round(255 * (0.5 * (1 + Math.cos(2.0 + t * 18.0 + 0.9))));
            return { r, g, b };
        }

        self.onmessage = (e) => {
            const { view, maxIterations } = e.data;
            const { width, height, centerX, centerY, zoom } = view;

            const offscreenCanvas = new OffscreenCanvas(width, height);
            const ctx = offscreenCanvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            
            const scale = 2.5 / (zoom * Math.min(width, height));

            for (let px = 0; px < width; px++) {
                for (let py = 0; py < height; py++) {
                    const cx = centerX + (px - width / 2) * scale;
                    const cy = centerY + (py - height / 2) * scale;
                    let x = 0.0, y = 0.0, iteration = 0;

                    while (x * x + y * y <= 4 && iteration < maxIterations) {
                        const x_temp = x * x - y * y + cx;
                        y = 2 * x * y + cy;
                        x = x_temp;
                        iteration++;
                    }
                    
                    const color = getColor(iteration, maxIterations);
                    const index = (py * width + px) * 4;
                    data[index] = color.r;
                    data[index + 1] = color.g;
                    data[index + 2] = color.b;
                    data[index + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            const bitmap = offscreenCanvas.transferToImageBitmap();
            self.postMessage({ bitmap: bitmap }, [bitmap]);
        };
    </script>

    <script>
        // --- CÓDIGO DEL HILO PRINCIPAL ---
        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');
        const renderIndicator = document.getElementById('render-indicator');

        // --- PARÁMETROS DE CONFIGURACIÓN ---
        let MAX_ITERATIONS = 150;
        const ZOOM_FACTOR = 1.4;

        // --- ESTADO DE LA VISTA Y TOQUES ---
        let view = { centerX: -0.7, centerY: 0, zoom: 1, width: 0, height: 0 };
        let renderTimeout;
        let initialPinchDistance = null;
        let lastPanPosition = null;

        // --- INICIALIZACIÓN DEL WEB WORKER ---
        const workerCode = document.getElementById('fractal-worker').textContent;
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(blob));

        worker.onmessage = (e) => {
            const { bitmap } = e.data;
            ctx.drawImage(bitmap, 0, 0);
            renderIndicator.classList.remove('visible');
            canvas.classList.remove('rendering');
        };

        function requestRender() {
            clearTimeout(renderTimeout);
            renderIndicator.classList.add('visible');
            canvas.classList.add('rendering');
            renderTimeout = setTimeout(() => {
                worker.postMessage({ view: view, maxIterations: MAX_ITERATIONS });
            }, 100); // 100ms de debounce
        }

        function resizeAndDraw() {
            view.width = window.innerWidth;
            view.height = window.innerHeight;
            canvas.width = view.width;
            canvas.height = view.height;
            requestRender();
        }

        // --- MANEJO DE EVENTOS ---

        // Evento de Rueda de Mouse (PC)
        canvas.addEventListener('wheel', (event) => {
            event.preventDefault();
            const mouseX = event.clientX;
            const mouseY = event.clientY;
            const scaleBefore = 2.5 / (view.zoom * Math.min(view.width, view.height));
            const complexXBefore = view.centerX + (mouseX - view.width / 2) * scaleBefore;
            const complexYBefore = view.centerY + (mouseY - view.height / 2) * scaleBefore;

            if (event.deltaY < 0) {
                view.zoom *= ZOOM_FACTOR;
                MAX_ITERATIONS = Math.floor(MAX_ITERATIONS * 1.08);
            } else {
                view.zoom /= ZOOM_FACTOR;
                MAX_ITERATIONS = Math.max(150, Math.floor(MAX_ITERATIONS / 1.08));
            }
            
            const scaleAfter = 2.5 / (view.zoom * Math.min(view.width, view.height));
            const complexXAfter = view.centerX + (mouseX - view.width / 2) * scaleAfter;
            const complexYAfter = view.centerY + (mouseY - view.height / 2) * scaleAfter;

            view.centerX += complexXBefore - complexXAfter;
            view.centerY += complexYBefore - complexYAfter;
            
            requestRender();
        });

        // Eventos Táctiles (Móvil)
        canvas.addEventListener('touchstart', (event) => {
            event.preventDefault();
            if (event.touches.length === 2) { // Pinch
                initialPinchDistance = Math.hypot(
                    event.touches[0].pageX - event.touches[1].pageX,
                    event.touches[0].pageY - event.touches[1].pageY
                );
                lastPanPosition = null;
            } else if (event.touches.length === 1) { // Pan
                lastPanPosition = { x: event.touches[0].pageX, y: event.touches[0].pageY };
                initialPinchDistance = null;
            }
        });

        canvas.addEventListener('touchmove', (event) => {
            event.preventDefault();
            const scale = 2.5 / (view.zoom * Math.min(view.width, view.height));

            if (event.touches.length === 2 && initialPinchDistance) { // Pinch-to-zoom
                const newPinchDistance = Math.hypot(
                    event.touches[0].pageX - event.touches[1].pageX,
                    event.touches[0].pageY - event.touches[1].pageY
                );
                const zoomAmount = newPinchDistance / initialPinchDistance;
                
                const midX = (event.touches[0].pageX + event.touches[1].pageX) / 2;
                const midY = (event.touches[0].pageY + event.touches[1].pageY) / 2;
                
                const complexXBefore = view.centerX + (midX - view.width / 2) * scale;
                const complexYBefore = view.centerY + (midY - view.height / 2) * scale;

                view.zoom *= zoomAmount;
                MAX_ITERATIONS = Math.max(150, 150 * Math.log10(view.zoom + 10));

                const newScale = 2.5 / (view.zoom * Math.min(view.width, view.height));
                const complexXAfter = view.centerX + (midX - view.width / 2) * newScale;
                const complexYAfter = view.centerY + (midY - view.height / 2) * newScale;

                view.centerX += complexXBefore - complexXAfter;
                view.centerY += complexYBefore - complexYAfter;

                initialPinchDistance = newPinchDistance;
                requestRender();

            } else if (event.touches.length === 1 && lastPanPosition) { // Pan
                const dx = event.touches[0].pageX - lastPanPosition.x;
                const dy = event.touches[0].pageY - lastPanPosition.y;
                
                view.centerX -= dx * scale;
                view.centerY -= dy * scale;
                
                lastPanPosition = { x: event.touches[0].pageX, y: event.touches[0].pageY };
                requestRender();
            }
        });

        canvas.addEventListener('touchend', (event) => {
            initialPinchDistance = null;
            lastPanPosition = null;
        });

        window.addEventListener('resize', resizeAndDraw);
        
        // --- DIBUJADO INICIAL ---
        resizeAndDraw();
    </script>

</body>
</html>
